<!DOCTYPE html>
<html lang="en">
	<head>
		<title>B234/S rug</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<div id="container" class="column-content" style="display: block; width: 100%; height: 620px;"></div>
		<div id="gui-container" style="position: absolute; top: 0px; left: 0px; z-index: 10;"></div>

		<script async type="module">
			import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js';
			import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';
			import Stats from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/stats.module.js';
			import { GUI } from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/dat.gui.module.js';
			import { MathUtils } from 'https://unpkg.com/three@0.121.1/build/three.module.js';
			import { SVGRenderer } from 'https://unpkg.com/three@0.121.1/examples/jsm/renderers/SVGRenderer.js';

			let container;
			let camera, controls, scene, stats, renderer;

			let	caCells, caCellsPrev;
			let caMesh;
			let caRuleBorn = [0, 0, 0, 0, 0, 0, 0, 0, 0];
			let caRuleStasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];
			let caOffset;
			let caColorBorn, caColorStasis, caColorDeath, caColorEmpty;

			let	rdCells, rdCellsPrev;
			let	rdMesh;
			let rdStates = [ 'Negative bubbles', 'Positive bubbles', 'Precritical bubbles', 'Worms & loops', 'Stable solutions', 'U-Skate World', 'Worms', 'Worms to maze', 'Negatons', 'Turing patterns', 'Chaos to Turing', 'Fingerprints', 'Chaos & negatons', 'Spots & worms', 'Replicating spots', 'Resonant mazes', 'Mazes', 'Mazes & chaos', 'Chaos' ]; 
			let rdColumns, rdRows;
			let rdOffset;
			let rdColor;

			let	msCells;
			let	msMesh, msMeshes;
			let msColumns, msRows;
			let msOffset;
			let msColor;

			const params = {
				caRule: 'B234/S',
				caColumns: 48,
				caRows: 24,
				caCellSize: 30,
				caGeneration: 20,
				caColorBorn: '#bb9f48',
				caColorStasis: '#2e2946',
				caColorDeath: '#cb95ae',
				caColorEmpty: '#ccbdc8',
				rdCellSize: 10,
				rdPresetA: "Mazes & chaos",
				rdPresetB: "Turing patterns",
				rdDiffusionAA: 1.0,
				rdDiffusionAB: 1.0,
				rdDiffusionBA: 0.5,
				rdDiffusionBB: 0.5,
				rdFeedA: 0.025,
				rdFeedB: 0.015,
				rdKillA: 0.050,
				rdKillB: 0.055,
				rdIteration: 20,
				rdColor: '#2e2946',
				msCellSize: 30,
				msColor: '#2e2946',
			}

			init();
			animate();

			function getMSState( cellA, cellB, cellC, cellD )
			{
				let state;
    
				state = (cellA > 0 ? 8 : 0) + (cellB > 0 ? 4 : 0) + (cellC > 0 ? 2 : 0) + (cellD > 0 ? 1 : 0);
				return (state);
			}

			function addTriangle( posA, posB, posC, index )
			{
				let geometry, vertices, material;

				geometry = new THREE.BufferGeometry();
				material = new THREE.MeshBasicMaterial( { color: params.msColor } );
				vertices = new Float32Array( [
									posA.x, posA.y, posA.z,
									posB.x, posB.y, posB.z,
									posC.x, posC.y, posC.z,
								] );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
				msMeshes.push( new THREE.Mesh( geometry, material ) );
				scene.add ( msMeshes[index] );
			}

			function addQuad( posA, posB, posC, posD, index )
			{
				let geometry, vertices, material;

				geometry = new THREE.BufferGeometry();
				material = new THREE.MeshBasicMaterial( { color: params.msColor } );
				vertices = new Float32Array( [
									posA.x, posA.y, posA.z,
									posB.x, posB.y, posB.z,
									posC.x, posC.y, posC.z,
									posA.x, posA.y, posA.z,
									posC.x, posC.y, posC.z,
									posD.x, posD.y, posD.z
								] );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
				msMeshes.push( new THREE.Mesh( geometry, material ) );
				scene.add ( msMeshes[index] );
			}

			function addPentagon( posA, posB, posC, posD, posE, index )
			{
				let geometry, vertices, material;

				geometry = new THREE.BufferGeometry();
				material = new THREE.MeshBasicMaterial( { color: params.msColor } );
				vertices = new Float32Array( [
									posA.x, posA.y, posA.z,
									posB.x, posB.y, posB.z,
									posC.x, posC.y, posC.z,
									posA.x, posA.y, posA.z,
									posC.x, posC.y, posC.z,
									posD.x, posD.y, posD.z,
									posA.x, posA.y, posA.z,
									posD.x, posD.y, posD.z,
									posE.x, posE.y, posE.z,
								] );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
				msMeshes.push( new THREE.Mesh( geometry, material ) );
				scene.add ( msMeshes[index] );
			}

			function displayMS()
			{
				let index;
				let position;
				let matrix;
				let cellA, cellB, cellC, cellD;
				let posA, posB, posC, posD;
				let posE, posF, posG, posH;			
				let state;
				let threshold;

				index = 0;
				position =	new THREE.Vector3();
				matrix =	new THREE.Matrix4();
				while ( msMeshes.length > 0 )
				{
					scene.remove( msMeshes[ msMeshes.length - 1 ] );
					msMeshes.pop();
				}
				msMeshes = [];
				threshold = 0.125;
				for ( let i = 0; i < msRows - 1; i++ )
					for ( let j = 0; j < msColumns - 1; j++ )
					{
						cellA = msCells[i][j] + threshold;
						cellB = msCells[i][j + 1] + threshold;
						cellC = msCells[i + 1][j + 1] + threshold;
						cellD = msCells[i + 1][j] + threshold;
						position.x = j * params.msCellSize - msOffset.x;
						position.y = i * params.msCellSize - msOffset.y;
						position.z = 1.;
						posA = new THREE.Vector3( position.x + params.msCellSize * cellA / ( cellA - cellB ), position.y, position.z );
						posB = new THREE.Vector3( position.x + params.msCellSize, position.y + params.msCellSize * cellB / ( cellB - cellC ), position.z );
						posC = new THREE.Vector3( position.x + params.msCellSize * ( 1.0 - cellC / ( cellC - cellD ) ), position.y + params.msCellSize, position.z );
						posD = new THREE.Vector3( position.x, position.y + params.msCellSize * ( 1.0 - cellD / ( cellD - cellA ) ), position.z );
						posE = new THREE.Vector3( position.x, position.y, position.z );
						posF = new THREE.Vector3( position.x + params.msCellSize, position.y, position.z );
						posG = new THREE.Vector3( position.x + params.msCellSize, position.y + params.msCellSize, position.z );
						posH = new THREE.Vector3( position.x, position.y + params.msCellSize, position.z );
						state = getMSState( Math.ceil( cellA ), Math.ceil( cellB ), Math.ceil( cellC ), Math.ceil( cellD ) );
						switch ( state )
						{	
							case 1:
								addTriangle( posC, posH, posD, index++);
								break;
							case 2:
								addTriangle( posB, posG, posC, index++);
								break;
							case 3:
								addQuad(posB, posG, posH, posD, index++);
								break;
							case 4:
								addTriangle( posA, posF, posB, index++);
								break;
							case 5:
								addTriangle( posC, posH, posD, index++);
								addTriangle( posA, posF, posB, index++);
								break;
							case 6:
								addQuad(posA, posF, posG, posC, index++);
								break;
							case 7:
								addPentagon(posA, posF, posG, posH, posD, index++);
								break;
							case 8:
								addTriangle( posA, posD, posE, index++);
								break;
							case 9:
								addQuad(posA, posC, posH, posE, index++);
								break;
							case 10:
								addTriangle( posA, posD, posE, index++);
								addTriangle( posB, posG, posC, index++);
								break;
							case 11:
								addPentagon(posE, posA, posB, posG, posH, index++);
								break;
							case 12:
								addQuad(posE, posF, posB, posD, index++);
								break;
							case 13:
								addPentagon(posE, posF, posB, posC, posH, index++);
								break;
							case 14:
								addPentagon(posE, posF, posG, posC, posD, index++);
								break;
							case 15:
								addQuad(posE, posF, posG, posH, index++);
								break;
						}
					}
				return ;
			}

			function updateMSCellsFromRD()
			{
				for ( let i = 0; i < msRows; i++ )
					for ( let j = 0, k = 0, l = 0; j < msColumns; j++ )
					{
						k = Math.floor( i / ( msRows - 1 ) * ( rdRows - 1 ) );
						l = Math.floor( j / ( msColumns - 1 ) * ( rdColumns - 1 ) );
						msCells[i][j] = rdCells[k][l][1] - rdCells[k][l][0];
					}
				return ;
			} 

			function setMSCells()
			{
				let msCellSubdivision;
				let geometry, material;

				msCellSubdivision = params.caCellSize / params.msCellSize;
				msColumns = Math.round(params.caColumns * msCellSubdivision) + 2;
				msRows = Math.round(params.caRows * msCellSubdivision) + 2;
				msCells = new Array( msRows );
				for ( let i = 0; i < msRows; i++ )
					msCells[i] = new Array( msColumns );
				msOffset =	new THREE.Vector2( msColumns, msRows ).divideScalar( 2.0 );
				msOffset =	msOffset.addScalar( -0.5 ).multiplyScalar( params.msCellSize );
				msColor =	new THREE.Color( params.msColor );
				geometry =	new THREE.PlaneGeometry( params.msCellSize, params.msCellSize, 0, 0);
				material =	new THREE.MeshBasicMaterial();
				scene.remove( msMesh );
				msMesh =	new THREE.InstancedMesh( geometry, material, msColumns * msRows );
				msMesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
				scene.add( msMesh );
				return ;	
			}

			function updateMS()
			{
				setMS();
				return ;
			}

			function setMS()
			{
				setMSCells();
				updateMSCellsFromRD();
				return ;
			}

			function displayRD()
			{
				let index;
				let position;
				let matrix;
				let value;

				index = 0;
				position =	new THREE.Vector3();
				matrix =	new THREE.Matrix4();
				for ( let i = 0; i < rdRows; i++ )
					for ( let j = 0; j < rdColumns; j++ )
					{
						value = rdCells[i][j][0] - rdCells[i][j][1];
						position.x = j * params.rdCellSize - rdOffset.x;
						position.y = i * params.rdCellSize - rdOffset.y;
						position.z = 0.5;
						matrix.setPosition( position );
						rdMesh.setMatrixAt( index, matrix );
						rdMesh.setColorAt( index, new THREE.Color( value, value, value ) );
						index++;
					}
				rdMesh.instanceMatrix.needsUpdate = true;
				rdMesh.instanceColor.needsUpdate = true;	
				return ;
			}

			function laplaceA( i, j )
			{
				let sumA;

				sumA = -rdCellsPrev[i][j][0];
				sumA += rdCellsPrev[i][j - 1][0] * 0.2;
				sumA += rdCellsPrev[i][j + 1][0] * 0.2;
				sumA += rdCellsPrev[i + 1][j][0] * 0.2;
				sumA += rdCellsPrev[i - 1][j][0] * 0.2;
				sumA += rdCellsPrev[i - 1][j - 1][0] * 0.05;
				sumA += rdCellsPrev[i - 1][j + 1][0] * 0.05;
				sumA += rdCellsPrev[i + 1][j + 1][0] * 0.05;
				sumA += rdCellsPrev[i + 1][j - 1][0] * 0.05;
				return ( sumA );
			}

			function laplaceB( i, j )
			{
				let sumB;

				sumB = -rdCellsPrev[i][j][1];
				sumB += rdCellsPrev[i][j - 1][1] * 0.2;
				sumB += rdCellsPrev[i][j + 1][1] * 0.2;
				sumB += rdCellsPrev[i + 1][j][1] * 0.2;
				sumB += rdCellsPrev[i - 1][j][1] * 0.2;
				sumB += rdCellsPrev[i - 1][j - 1][1] * 0.05;
				sumB += rdCellsPrev[i - 1][j + 1][1] * 0.05;
				sumB += rdCellsPrev[i + 1][j + 1][1] * 0.05;
				sumB += rdCellsPrev[i + 1][j - 1][1] * 0.05;
				return ( sumB );
			}

			function updateRDCells()
			{	
				let a, b, abb;
				let feed, kill;
				let diffusionA, diffusionB;

				rdCellsPrev = [];
				for ( let i = 0; i < rdCells.length; i++ )
				{
					rdCellsPrev[i] = rdCells[i].slice( 0 );
					for ( let j = 0; j < rdCells[i].length; j++ )
						rdCellsPrev[i][j] = rdCells[i][j].slice( 0 );
				}
				for ( let i = 1; i < rdRows - 1; i++ )
					for ( let j = 1; j < rdColumns - 1; j++ )
					{
						a = rdCellsPrev[i][j][0];
						b = rdCellsPrev[i][j][1];
						abb = a * b * b;
						feed = THREE.MathUtils.lerp( params.rdFeedA, params.rdFeedB, i / rdRows );
						kill = THREE.MathUtils.lerp( params.rdKillA, params.rdKillB, j / rdColumns );
						diffusionA = THREE.MathUtils.lerp( params.rdDiffusionAA, params.rdDiffusionAB, i / rdRows );
						diffusionB = THREE.MathUtils.lerp( params.rdDiffusionBA, params.rdDiffusionBB, j / rdColumns );
						rdCells[i][j][0] = a + diffusionA * laplaceA( i, j ) - abb + feed * ( 1. - a );
						rdCells[i][j][1] = b + diffusionB * laplaceB( i, j ) + abb - ( kill + feed ) * b;
						rdCells[i][j][0] = THREE.MathUtils.clamp( rdCells[i][j][0], 0., 1. );
						rdCells[i][j][1] = THREE.MathUtils.clamp( rdCells[i][j][1], 0., 1. );
					}
				return ;				
			}

			function updateRDCellsFromCA()
			{
				let distance;
				let positionCA, positionRD;

				distance =		params.caCellSize * params.caCellSize / 16.0;
				positionCA =	new THREE.Vector2();
				positionRD =	new THREE.Vector2();
				for ( let i = 0; i < rdRows; i++ )
					for ( let j = 0, k = 0, l = 0; j < rdColumns; j++ )
					{
						k = Math.floor( i / rdRows * params.caRows );
						l = Math.floor( j / rdColumns * params.caColumns );
						positionCA.x = l * params.caCellSize - caOffset.x;
						positionCA.y = -k * params.caCellSize + caOffset.y;
						positionRD.x = j * params.rdCellSize - rdOffset.x;
						positionRD.y = -i * params.rdCellSize + rdOffset.y;
						if ( caCells[k][l] > 0 && positionRD.distanceToSquared(positionCA) < distance )
							rdCells[i][j] = [1.0, 1.0];
					}
				return ;
			}

			function setRDCells()
			{
				let rdCellSubdivision;
				let geometry, material;

				rdCellSubdivision = params.caCellSize / params.rdCellSize;
				rdColumns = Math.round(params.caColumns * rdCellSubdivision) + 2;
				rdRows = Math.round(params.caRows * rdCellSubdivision) + 2;
				rdCells = new Array( rdRows );
				for ( let i = 0; i < rdRows; i++ )
				{
					rdCells[i] = new Array( rdColumns );
					for ( let j = 0; j < rdColumns; j++ )
						rdCells[i][j] = [1.0, 0.0];
				}
				rdOffset =	new THREE.Vector2( rdColumns, rdRows ).divideScalar( 2.0 );
				rdOffset =	rdOffset.addScalar( -0.5 ).multiplyScalar( params.rdCellSize );
				rdColor =	new THREE.Color( params.rdColor );
				geometry =	new THREE.PlaneGeometry( params.rdCellSize, params.rdCellSize, 0, 0);
				material =	new THREE.MeshBasicMaterial();
				scene.remove( rdMesh );
				rdMesh =	new THREE.InstancedMesh( geometry, material, rdColumns * rdRows );
				rdMesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
				scene.add( rdMesh );
				msMeshes = [];
				return ;
			}

			function updateRD()
			{
				setRD();
				return ;
			}

			function setRDParamsA( diffusionA, diffusionB, feed, kill )
			{
				params.rdDiffusionAA = diffusionA;
				params.rdDiffusionBA = diffusionB;
				params.rdFeedA = feed;
				params.rdKillA = kill;
				return ;
			}

			function setRDParamsB( diffusionA, diffusionB, feed, kill )
			{
				params.rdDiffusionAB = diffusionA;
				params.rdDiffusionBB = diffusionB;
				params.rdFeedB = feed;
				params.rdKillB = kill;
				return ;
			}

			function setRD()
			{
				setRDCells();		
				if ( params.rdPresetA === 'Negative bubbles')			setRDParamsA( 0.2097, 0.1050, 0.0980, 0.0555 );
				else if ( params.rdPresetA === 'Positive bubbles' )		setRDParamsA( 0.2097, 0.1050, 0.0980, 0.0570 );
				else if ( params.rdPresetA === 'Precritical bubbles' )	setRDParamsA( 0.2097, 0.1050, 0.0820, 0.0590 );
				else if ( params.rdPresetA === 'Worms & loops' )		setRDParamsA( 0.2097, 0.1050, 0.0820, 0.0600 );
				else if ( params.rdPresetA === 'Stable solutions' )		setRDParamsA( 0.2097, 0.1050, 0.0740, 0.0640 );
				else if ( params.rdPresetA === 'U-Skate World' )		setRDParamsA( 0.2097, 0.1050, 0.0620, 0.0609 );
				else if ( params.rdPresetA === 'Worms' )				setRDParamsA( 0.2097, 0.1050, 0.0580, 0.0650 );
				else if ( params.rdPresetA === 'Worms to maze' )		setRDParamsA( 0.2097, 0.1050, 0.0460, 0.0630 );
				else if ( params.rdPresetA === 'Negatons' )				setRDParamsA( 0.2097, 0.1050, 0.0460, 0.0594 );
				else if ( params.rdPresetA === 'Turing patterns' )		setRDParamsA( 0.2097, 0.1050, 0.0420, 0.0590 );
				else if ( params.rdPresetA === 'Chaos to Turing' )		setRDParamsA( 0.2097, 0.1050, 0.0390, 0.0580 );
				else if ( params.rdPresetA === 'Fingerprints' )			setRDParamsA( 0.2097, 0.1050, 0.0370, 0.0600 );
				else if ( params.rdPresetA === 'Chaos & negatons' )		setRDParamsA( 0.2097, 0.1050, 0.0353, 0.0566 );
				else if ( params.rdPresetA === 'Spots & worms' )		setRDParamsA( 0.2097, 0.1050, 0.0340, 0.0618 );
				else if ( params.rdPresetA === 'Replicating spots' )	setRDParamsA( 0.2097, 0.1050, 0.0300, 0.0630 );
				else if ( params.rdPresetA === 'Resonant mazes' )		setRDParamsA( 0.2097, 0.1050, 0.0300, 0.0565 );
				else if ( params.rdPresetA === 'Mazes' )				setRDParamsA( 0.2097, 0.1050, 0.0290, 0.0570 );
				else if ( params.rdPresetA === 'Mazes & chaos' )		setRDParamsA( 0.2097, 0.1050, 0.0260, 0.0550 );
				else if ( params.rdPresetA === 'Chaos' )				setRDParamsA( 0.2097, 0.1050, 0.0260, 0.0510 );
				if ( params.rdPresetB === 'Negative bubbles')			setRDParamsB( 0.2097, 0.1050, 0.0980, 0.0555 );
				else if ( params.rdPresetB === 'Positive bubbles' )		setRDParamsB( 0.2097, 0.1050, 0.0980, 0.0570 );
				else if ( params.rdPresetB === 'Precritical bubbles' )	setRDParamsB( 0.2097, 0.1050, 0.0820, 0.0590 );
				else if ( params.rdPresetB === 'Worms & loops' )		setRDParamsB( 0.2097, 0.1050, 0.0820, 0.0600 );
				else if ( params.rdPresetB === 'Stable solutions' )		setRDParamsB( 0.2097, 0.1050, 0.0740, 0.0640 );
				else if ( params.rdPresetB === 'U-Skate World' )		setRDParamsB( 0.2097, 0.1050, 0.0620, 0.0609 );
				else if ( params.rdPresetB === 'Worms' )				setRDParamsB( 0.2097, 0.1050, 0.0580, 0.0650 );
				else if ( params.rdPresetB === 'Worms to maze' )		setRDParamsB( 0.2097, 0.1050, 0.0460, 0.0630 );
				else if ( params.rdPresetB === 'Negatons' )				setRDParamsB( 0.2097, 0.1050, 0.0460, 0.0594 );
				else if ( params.rdPresetB === 'Turing patterns' )		setRDParamsB( 0.2097, 0.1050, 0.0420, 0.0590 );
				else if ( params.rdPresetB === 'Chaos to Turing' )		setRDParamsB( 0.2097, 0.1050, 0.0390, 0.0580 );
				else if ( params.rdPresetB === 'Fingerprints' )			setRDParamsB( 0.2097, 0.1050, 0.0370, 0.0600 );
				else if ( params.rdPresetB === 'Chaos & negatons' )		setRDParamsB( 0.2097, 0.1050, 0.0353, 0.0566 );
				else if ( params.rdPresetB === 'Spots & worms' )		setRDParamsB( 0.2097, 0.1050, 0.0340, 0.0618 );
				else if ( params.rdPresetB === 'Replicating spots' )	setRDParamsB( 0.2097, 0.1050, 0.0300, 0.0630 );
				else if ( params.rdPresetB === 'Resonant mazes' )		setRDParamsB( 0.2097, 0.1050, 0.0300, 0.0565 );
				else if ( params.rdPresetB === 'Mazes' )				setRDParamsB( 0.2097, 0.1050, 0.0290, 0.0570 );
				else if ( params.rdPresetB === 'Mazes & chaos' )		setRDParamsB( 0.2097, 0.1050, 0.0260, 0.0550 );
				else if ( params.rdPresetB === 'Chaos' )				setRDParamsB( 0.2097, 0.1050, 0.0260, 0.0510 );
				updateRDCellsFromCA();
				return ;
			}

			function displayCA()
			{
				let index;
				let position;
				let matrix;

				index = 0;
				position =		new THREE.Vector3();
				matrix =		new THREE.Matrix4();
				for ( let i = 0; i < params.caRows; i++ )
					for ( let j = 0; j < params.caColumns; j++ )
					{
						position.x = j * params.caCellSize - caOffset.x;
						position.y = -i * params.caCellSize + caOffset.y;
						position.z = 0.;
						matrix.setPosition( position );
						caMesh.setMatrixAt( index, matrix );
						if (caCellsPrev[i][j] != 0 || caCells[i][j] != 0)
						{
							if ( caCellsPrev[i][j] == 0 )
								caMesh.setColorAt( index, caColorBorn );
							else if ( caCells[i][j] == 0 )
								caMesh.setColorAt( index, caColorDeath );
							else
								caMesh.setColorAt( index, caColorStasis );
						}
						else
							caMesh.setColorAt( index, caColorEmpty );
						index++;
					}
				caMesh.instanceColor.needsUpdate = true;
				caMesh.instanceColor.needsUpdate = true;
				return ;
			}

			function getCANeighbors( x, y )
			{
				let neighbors;
				
				neighbors = 0;
				x += params.caColumns;
				y += params.caRows;
				for ( let i = -1; i <= 1; i++ )
					for ( let j = -1; j <= 1; j++ )
						neighbors += caCellsPrev[( i + y ) % params.caRows][( j + x ) % params.caColumns];
				return ( neighbors );
			}

			function updateCACells()
			{
				let neighbors;

				caCellsPrev = [];
				for ( let i = 0; i < caCells.length; i++ )
					caCellsPrev[i] = caCells[i].slice( 0 );
				for ( let i = 0; i < params.caRows; i++ )
					for ( let j = 0, index = 0; j < params.caColumns; j++ )
					{
						neighbors = getCANeighbors( j, i );
						if ( caCellsPrev[i][j] == 0 && caRuleBorn[neighbors] == 1 )
							caCells[i][j] = 1;
						else if ( caCellsPrev[i][j] == 1 && caRuleStasis[neighbors] == 0 )
							caCells[i][j] = 0;
					}
				return ;
			}

			function setCACells()
			{
				let	halfColumns, halfRows;
				let geometry, material;

				halfColumns = params.caColumns / 2;
				halfRows = params.caRows / 2;
				caCells = new Array( params.caRows );
				for ( let i = 0; i < params.caRows; i++ )
					caCells[i] = new Array( params.caColumns ).fill( 0 );
				caCells[0][0] = 1;
				caCells[0][params.caColumns - 1] = 1;
				caCells[params.caRows - 1][0] = 1;
				caCells[params.caRows - 1][params.caColumns - 1] = 1;
				caCells[halfRows - 1][halfColumns - 1] = 1;
				caCells[halfRows - 1][halfColumns] = 1;
				caCells[halfRows][halfColumns - 1] = 1;
				caCells[halfRows][halfColumns] = 1;
				caOffset =		new THREE.Vector2( params.caColumns, params.caRows ).divideScalar( 2.0 );
				caOffset =		caOffset.addScalar( -0.5 ).multiplyScalar( params.caCellSize );
				caColorBorn = 	new THREE.Color( params.caColorBorn );
				caColorStasis =	new THREE.Color( params.caColorStasis );
				caColorDeath =	new THREE.Color( params.caColorDeath );
				caColorEmpty =	new THREE.Color( params.caColorEmpty );
				geometry =		new THREE.PlaneGeometry( params.caCellSize, params.caCellSize, 0, 0);
				material =		new THREE.MeshBasicMaterial();
				scene.remove( caMesh );
				caMesh =		new THREE.InstancedMesh( geometry, material, params.caColumns * params.caRows );
				caMesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
				scene.add( caMesh );
				return ;
			}

			function setCARuleState( index, rule )
			{
				for ( let i = 0; i < 9; i++ )
					if ( params.caRule.charCodeAt( index ) == '0'.charCodeAt(0) + i )
						rule[i] = 1;
				return ;
			}

			function setCARule()
			{
				let	index;

				index = 0;
				for ( let i = 0; i < 9; i++ )
					caRuleBorn[i] = caRuleStasis[i] = 0;
				if ( params.caRule.charAt( 0 ) == 'B' )
				{
					while ( ++index < params.caRule.length && params.caRule.charAt( index ) != '/' )
						setCARuleState( index, caRuleBorn );
					while ( ++index < params.caRule.length )
						setCARuleState( index, caRuleStasis );
				}
				return ;
			}

			function updateCA()
			{
				setCA();
				setRD();
				return ;
			}

			function setCA()
			{
				setCARule();
				setCACells();
				for ( let i = 0; i < params.caGeneration; i++ )
					updateCACells();
				displayCA();
				return ;
			}

			/*
			** User interface function
			*/

			function createGUI()
			{
				let gui;
				let folderCA, folderRD, folderMS;
				let svgExport;

				gui = new GUI();
				document.getElementById('gui-container').appendChild(gui.domElement);
				folderCA = gui.addFolder( 'Cellular automata' );
				folderCA.add( params, 'caRule').name( 'rule' ).listen().onChange( function () { updateCA() } );
				folderCA.add( params, 'caColumns', 16, 64, 4 ).name( 'columns' ).listen().onChange( function () { updateCA() } );
				folderCA.add( params, 'caRows', 16, 64, 4 ).name( 'rows' ).listen().onChange( function () { updateCA() } );
				folderCA.add( params, 'caCellSize', 4, 40, 1 ).name( 'cellSize' ).listen().onChange( function () { updateCA() } );
				folderCA.add( params, 'caGeneration', 0, 120, 1 ).name( 'generation' ).listen().onChange( function () { updateCA() } );
				folderCA.addColor( params, 'caColorBorn' ).name( 'colorBorn' ).listen().onChange( function () { updateCACells() } );
				folderCA.addColor( params, 'caColorStasis' ).name( 'colorStasis' ).listen().onChange( function () { updateCACells() } );
				folderCA.addColor( params, 'caColorDeath' ).name( 'colorDeath' ).listen().onChange( function () { updateCACells() } );
				folderRD = gui.addFolder( 'Reaction diffusion' );
				folderRD.add( params, 'rdCellSize', 1, 10, 1 ).name( 'cellSize' ).listen().onChange( function () { updateRD() } );
				folderRD.add( params, 'rdPresetA', rdStates ).name( 'presetIn' ).onChange( function () { updateRD() } );
				folderRD.add( params, 'rdPresetB', rdStates ).name( 'presetOut' ).onChange( function () { updateRD() } );
				folderRD.add( params, 'rdIteration', 0, 240, 1 ).name( 'iteration' ).listen().onChange( function () { updateRD() } );
				folderMS = gui.addFolder( 'Marching square' );
				folderMS.add( params, 'msCellSize', 2, 20, 1 ).name( 'cellSize' ).listen().onChange( function () { updateMS() } );
				folderMS.addColor( params, 'msColor' ).name( 'color' ).listen().onChange( function () { updateMS() } );
				svgExport = { add:function(){ exportToSVG(); } };
				gui.add( svgExport, 'add' ).name( 'Export to SVG' );
				return ;
			}

			function init()
			{
				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 45, container.clientWidth / container.clientHeight, 1, 2000 );
				camera.position.z = 1200;
				controls = new OrbitControls( camera, container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf8f8ff );

				stats = new Stats();
				container.appendChild( stats.dom );

				setCA();
				setRD();
				setMS();
				createGUI();

				renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( container.clientWidth, container.clientHeight );

				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
				return ;
			}

			function onWindowResize()
			{
				camera.aspect = container.clientWidth / container.clientHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( container.clientWidth, container.clientHeight );
				return ;
			}

			function animate()
			{
				requestAnimationFrame( animate );
				updateRDCells();
				//displayRD();
				updateMSCellsFromRD();
				displayMS();
				controls.update();
				stats.update();
				renderer.render( scene, camera );
				return ;
			}

			function exportToSVG()
			{
				let rendererSVG;
				
				rendererSVG = new SVGRenderer();
				rendererSVG.setSize( window.innerWidth, window.innerHeight );
				rendererSVG.render( scene, camera );
				saveToSVG(rendererSVG, "rug.svg");
				return ;
			}

			function saveToSVG(rendererSVG, filename)
			{
				var XMLS = new XMLSerializer(); 
				var svgfile = XMLS.serializeToString(rendererSVG.domElement); 
				
				var svgData = svgfile;
				var preface = '<?xml version="1.0" standalone="no"?>\r\n';
				var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
				var svgUrl = URL.createObjectURL(svgBlob);
				var downloadLink = document.createElement("a");
				downloadLink.href = svgUrl;
				downloadLink.download = filename;
				document.body.appendChild(downloadLink);
				downloadLink.click();
				document.body.removeChild(downloadLink);
				return ;
			}

			window.addEventListener('sempliceTransitionInDone', function (e) {
				init();
				animate();
				camera.aspect = container.clientWidth / container.clientHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( container.clientWidth, container.clientHeight );
				return ;
			}, false);
		</script>
	</body>
</html>
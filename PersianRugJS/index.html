<!DOCTYPE html>
<html lang="en">
	<head>
		<title>B234/S rug</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<div id="container" class="column-content" style="display: block; width: 100%; height: 620px;"></div>
		<div id="gui-container" style="position: absolute; top: 0px; left: 0px; z-index: 10;"></div>

		<script async type="module">
			import * as THREE from 'https://cdn.skypack.dev/three@0.121.1/build/three.module.js';
			import { OrbitControls } from 'https://cdn.skypack.dev/three@0.121.1/examples/jsm/controls/OrbitControls.js';
			import { GUI } from 'https://cdn.skypack.dev/three@0.121.1/examples/jsm/libs/dat.gui.module.js';
			import { MathUtils } from 'https://cdn.skypack.dev/three@0.121.1/build/three.module.js';
			import { SVGRenderer } from 'https://cdn.skypack.dev/three@0.121.1/examples/jsm/renderers/SVGRenderer.js';

			let container;
			let camera, controls, scene, renderer;
			let frameCount = 0;

			let caCells, caCellsPrev;
			let caMesh;
			let caMeshes = [];
			let caRuleBorn = [0, 0, 0, 0, 0, 0, 0, 0, 0];
			let caRuleStasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];
			let caOffset;
			let caColorBorn, caColorStasis, caColorDeath, caColorBack;

			let rdCells, rdCellsPrev;
			let rdCellSub;
			let rdMesh;
			let rdStates = [ 'Negative bubbles', 'Positive bubbles', 'Precritical bubbles', 'Worms & loops', 'Stable solutions', 'U-Skate World', 'Worms', 'Worms to maze', 'Negatons', 'Turing patterns', 'Chaos to Turing', 'Fingerprints', 'Chaos & negatons', 'Spots & worms', 'Replicating spots', 'Resonant mazes', 'Mazes', 'Mazes & chaos', 'Chaos' ]; 
			let rdPresetAIndex = 0;
			let rdPresetBIndex = 0;
			let rdColumns, rdRows, rdOffset;
			let rdColor;

			let msCellSize;
			let msCells;
			let msMesh, msMeshes;

			const ui = {
				caRule: 'B234/S',
				caColumns: 48,
				caRows: 24,
				caCellSize: 30,
				caGeneration: 20,
				caColorBorn: '#c0c0ff',
				caColorStasis: '#000000',
				caColorDeath: '#e0e0ff',
				caColorBack: '#f8f8ff',
				rdCellSize: 7.5,
				rdPresetA: 'Fingerprints',
				rdPresetB: 'Stable solutions',
				rdDiffusionA: 0.2097,
				rdDiffusionB: 0.1050,
				rdFeedA: 0.,
				rdFeedB: 0.,
				rdKillA: 0.,
				rdKillB: 0.,
				rdIteration: 1024,
				rdColor: '#5050ff',
			}

			init();
			animate();

			function getMSState( cells )
			{
				let state;
    
				state = (cells[0] > 0. ? 8 : 0) + (cells[1] > 0. ? 4 : 0)
					+ (cells[2] > 0. ? 2 : 0) + (cells[3] > 0. ? 1 : 0);
				return (state);
			}

			function setTriPositions( vecA, vecB, vecC )
			{
				let positions;

				positions = new Float32Array( 27 );
				positions.set( new Float32Array( [
									vecA.x, vecA.y, vecA.z,
									vecB.x, vecB.y, vecB.z,
									vecC.x, vecC.y, vecC.z
								] ), 0 );
				return ( positions );
			}

			function setTrisPositions( vecA, vecB, vecC, vecD, vecE, vecF )
			{
				let positions;

				positions = new Float32Array( 27 );
				positions.set( new Float32Array( [
									vecA.x, vecA.y, vecA.z,
									vecB.x, vecB.y, vecB.z,
									vecC.x, vecC.y, vecC.z,
									vecD.x, vecD.y, vecD.z,
									vecE.x, vecE.y, vecE.z,
									vecF.x, vecF.y, vecF.z
								] ), 0 );
				return ( positions );
			}

			function setQuadPositions( vecA, vecB, vecC, vecD )
			{
				let positions;

				positions = new Float32Array( 27 );
				positions.set( new Float32Array( [
									vecA.x, vecA.y, vecA.z,
									vecB.x, vecB.y, vecB.z,
									vecC.x, vecC.y, vecC.z,
									vecA.x, vecA.y, vecA.z,
									vecC.x, vecC.y, vecC.z,
									vecD.x, vecD.y, vecD.z,
								] ), 0 );
				return ( positions );
			}

			function setPentPositions( vecA, vecB, vecC, vecD, vecE )
			{
				let positions;

				positions = new Float32Array( [
									vecA.x, vecA.y, vecA.z,
									vecB.x, vecB.y, vecB.z,
									vecC.x, vecC.y, vecC.z,
									vecA.x, vecA.y, vecA.z,
									vecC.x, vecC.y, vecC.z,
									vecD.x, vecD.y, vecD.z,
									vecA.x, vecA.y, vecA.z,
									vecD.x, vecD.y, vecD.z,
									vecE.x, vecE.y, vecE.z,
								] );
				return ( positions );
			}

			function displayMS()
			{
				let index;
				let cells;
				let v;
				let positions, position;
				let h;

				index =	0;
				h =		0.2;
				cells =	[4];
				v =		[8];
				position = new THREE.Vector3();
				positions = msMesh.geometry.attributes.position.array;
				for ( let i = 0; i < rdRows - 1; i++ )
					for ( let j = 0; j < rdColumns - 1; j++ )
					{
						cells[0] = msCells[i][j] + h;
						cells[1] = msCells[i][j + 1] + h;
						cells[2] = msCells[i + 1][j + 1] + h;
						cells[3] = msCells[i + 1][j] + h;

						position.x = j * msCellSize - rdOffset.x;
						position.y = i * msCellSize - rdOffset.y;
						position.z = 0.1;

						v[0] = new THREE.Vector3( msCellSize * cells[0] / ( cells[0] - cells[1] ), 0., 0. ).add( position );
						v[1] = new THREE.Vector3( msCellSize, msCellSize * cells[1] / ( cells[1] - cells[2] ), 0. ).add( position );
						v[2] = new THREE.Vector3( msCellSize * ( 1.0 - cells[2] / ( cells[2] - cells[3] ) ), msCellSize, 0. ).add( position );
						v[3] = new THREE.Vector3( 0., msCellSize * ( 1.0 - cells[3] / ( cells[3] - cells[0] ) ), 0. ).add( position );
						v[4] = position.clone();
						v[5] = new THREE.Vector3( msCellSize, 0., 0. ).add( position );
						v[6] = new THREE.Vector3( msCellSize, msCellSize, 0. ).add( position );
						v[7] = new THREE.Vector3( 0., msCellSize, 0 ).add( position );

						for ( let k = 0; k < 4; k++ )
							cells[k] = Math.ceil( cells[k] )
						switch ( getMSState( cells ) )
						{	
							case 0:
								positions.set( new Float32Array( 27 ), index ); break;
							case 1:
								positions.set( setTriPositions( v[2], v[7], v[3] ), index ); break;
							case 2:
								positions.set( setTriPositions( v[1], v[6], v[2] ), index ); break;
							case 3:
								positions.set( setQuadPositions( v[1], v[6], v[7], v[3] ), index ); break;
							case 4:
								positions.set( setTriPositions( v[0], v[5], v[1] ), index ); break;
							case 5:
								positions.set( setTrisPositions( v[2], v[7], v[3], v[0], v[5], v[1] ), index ); break;
							case 6:
								positions.set( setQuadPositions( v[0], v[5], v[6], v[2] ), index ); break;
							case 7:
								positions.set( setPentPositions( v[0], v[5], v[6], v[7], v[3] ), index ); break;
							case 8:
								positions.set( setTriPositions( v[0], v[3], v[4] ), index ); break;
							case 9:
								positions.set( setQuadPositions( v[0], v[2], v[7], v[4] ), index ); break;
							case 10:
								positions.set( setTrisPositions( v[0], v[3], v[4], v[1], v[6], v[2] ), index ); break;
							case 11:
								positions.set( setPentPositions( v[4], v[0], v[1], v[6], v[7] ), index ); break;
							case 12:
								positions.set( setQuadPositions( v[4], v[5], v[1], v[3] ), index ); break;
							case 13:
								positions.set( setPentPositions( v[4], v[5], v[1], v[2], v[7] ), index ); break;
							case 14:
								positions.set( setPentPositions( v[4], v[5], v[6], v[2], v[3] ), index ); break;
							case 15:
								positions.set( setQuadPositions( v[4], v[5], v[6], v[7] ), index ); break;
						}
						index += 27;
					}
				msMesh.geometry.attributes.position.needsUpdate = true;
				return ;
			}

			function updateMSCellsFromRD()
			{
				for ( let i = 0; i < rdRows; i++ )
					for ( let j = 0; j < rdColumns; j++ )
						msCells[i][j] = rdCells[i][j][1] - rdCells[i][j][0];
				return ;
			}

			function setMSMesh()
			{
				let positions
				let geometry, material;

				positions =	new Float32Array( (rdRows - 1) * (rdColumns - 1) * 9 * 3 );
				geometry =	new THREE.BufferGeometry();
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				material = new THREE.MeshBasicMaterial( { color: rdColor, side: THREE.DoubleSideÂ } );
				scene.remove( msMesh );
				msMesh = new THREE.Mesh( geometry, material );
				scene.add( msMesh );
				return ;
			}

			function setMSCells()
			{
				let msCellSubdivision;
				let positions, geometry, material;

				msCellSize = ui.rdCellSize;
				msCells = new Array( rdRows );
				for ( let i = 0; i < rdRows; i++ )
					msCells[i] = new Array( rdColumns );
				return ;
			}

			function setMS()
			{
				setMSCells();
				setMSMesh();
				updateMSCellsFromRD();
				return ;
			}

			/*
			function displayRD()
			{
				let index;
				let position;
				let matrix;
				let value;

				index = 0;
				position =	new THREE.Vector3();
				matrix =	new THREE.Matrix4();
				for ( let i = 0; i < rdRows; i++ )
					for ( let j = 0; j < rdColumns; j++ )
					{
						value = rdCells[i][j][0] - rdCells[i][j][1];
						position.x = j * ui.rdCellSize - rdOffset.x;
						position.y = i * ui.rdCellSize - rdOffset.y;
						position.z = 0.5;
						matrix.setPosition( position );
						rdMesh.setMatrixAt( index, matrix );
						rdMesh.setColorAt( index, new THREE.Color( value, value, value ) );
						index++;
					}
				rdMesh.instanceMatrix.needsUpdate = true;
				rdMesh.instanceColor.needsUpdate = true;
				return ;
			}
			*/

			function laplaceA( i, j )
			{
				let sumA;

				sumA = -rdCellsPrev[i][j][0];
				sumA += rdCellsPrev[i][j - 1][0] * 0.2;
				sumA += rdCellsPrev[i][j + 1][0] * 0.2;
				sumA += rdCellsPrev[i + 1][j][0] * 0.2;
				sumA += rdCellsPrev[i - 1][j][0] * 0.2;
				sumA += rdCellsPrev[i - 1][j - 1][0] * 0.05;
				sumA += rdCellsPrev[i - 1][j + 1][0] * 0.05;
				sumA += rdCellsPrev[i + 1][j + 1][0] * 0.05;
				sumA += rdCellsPrev[i + 1][j - 1][0] * 0.05;
				return ( sumA );
			}

			function laplaceB( i, j )
			{
				let sumB;

				sumB = -rdCellsPrev[i][j][1];
				sumB += rdCellsPrev[i][j - 1][1] * 0.2;
				sumB += rdCellsPrev[i][j + 1][1] * 0.2;
				sumB += rdCellsPrev[i + 1][j][1] * 0.2;
				sumB += rdCellsPrev[i - 1][j][1] * 0.2;
				sumB += rdCellsPrev[i - 1][j - 1][1] * 0.05;
				sumB += rdCellsPrev[i - 1][j + 1][1] * 0.05;
				sumB += rdCellsPrev[i + 1][j + 1][1] * 0.05;
				sumB += rdCellsPrev[i + 1][j - 1][1] * 0.05;
				return ( sumB );
			}

			function updateRDCells()
			{	
				let a, b, abb;
				let feed, kill;

				for ( let i = 1; i < rdRows - 1; i++ )
					for ( let j = 1; j < rdColumns - 1; j++ )
					{
						a = rdCellsPrev[i][j][0];
						b = rdCellsPrev[i][j][1];

						abb = a * b * b;
						
						feed = THREE.MathUtils.mapLinear( i, 1, rdRows - 2, ui.rdFeedB, ui.rdFeedA );
						kill = THREE.MathUtils.mapLinear( j, 1, rdColumns - 2, ui.rdKillA, ui.rdKillB );

						rdCells[i][j][0] = a + ui.rdDiffusionA * laplaceA( i, j ) - abb + feed * ( 1. - a );
						rdCells[i][j][1] = b + ui.rdDiffusionB * laplaceB( i, j ) + abb - ( kill + feed ) * b;
						
						rdCells[i][j][0] = THREE.MathUtils.clamp( rdCells[i][j][0], 0., 1. );
						rdCells[i][j][1] = THREE.MathUtils.clamp( rdCells[i][j][1], 0., 1. );
					}
				rdCellsPrev = [];
				for ( let i = 0; i < rdCells.length; i++ )
				{
					rdCellsPrev[i] = rdCells[i].slice( 0 );
					for ( let j = 0; j < rdCells[i].length; j++ )
						rdCellsPrev[i][j] = rdCells[i][j].slice( 0 );
				}
				return ;
			}

			function updateRDCellsFromCA()
			{
				let distance;
				let positionCA, positionRD;

				distance =		ui.rdCellSize * ui.rdCellSize * 2.;
				positionCA =	new THREE.Vector2();
				positionRD =	new THREE.Vector2();
				for ( let i = 1; i < rdRows - 1; i++ )
					for ( let j = 1, k = 0, l = 0; j < rdColumns - 1; j++ )
					{
						k = Math.floor( (i - 1) / rdCellSub );
						l = Math.floor( (j - 1) / rdCellSub );
						positionCA.x = l * ui.caCellSize - caOffset.x;
						positionCA.y = -k * ui.caCellSize + caOffset.y;
						positionRD.x = j * ui.rdCellSize - rdOffset.x;
						positionRD.y = -i * ui.rdCellSize + rdOffset.y;
						if ( caCells[k][l] > 0 && positionRD.distanceToSquared(positionCA) < distance )
							rdCellsPrev[i][j] = [1.0, 1.0];
					}
				return ;
			}

			/*
			function setRDMesh()
			{
				let geometry, material;

				geometry =	new THREE.PlaneGeometry( ui.rdCellSize / 2., ui.rdCellSize / 2., 0, 0);
				material =	new THREE.MeshBasicMaterial();
				scene.remove( rdMesh );
				rdMesh =	new THREE.InstancedMesh( geometry, material, rdColumns * rdRows );
				rdMesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
				scene.add( rdMesh );
				return ;
			}
			*/

			function setRDCells()
			{
				rdCells = new Array( rdRows );
				rdCellsPrev = new Array( rdRows );
				for ( let i = 0; i < rdRows; i++ )
				{
					rdCells[i] = new Array( rdColumns );
					rdCellsPrev[i] = new Array( rdColumns );
					for ( let j = 0; j < rdColumns; j++ )
					{
						rdCells[i][j] = [1.0, 0.0];
						rdCellsPrev[i][j] = [1.0, 0.0];
					}
				}
				return ;
			}

			function setRDVariables()
			{
				rdCellSub =	ui.caCellSize / ui.rdCellSize;
				rdColumns =	Math.round(ui.caColumns * rdCellSub) + 2;
				rdRows =	Math.round(ui.caRows * rdCellSub) + 2;
				rdCellSub =	(rdRows - 2) / ui.caRows;
				rdOffset =	new THREE.Vector2( rdColumns, rdRows ).divideScalar( 2. );
				rdOffset =	rdOffset.addScalar( -0.5 ).multiplyScalar( ui.rdCellSize );
				rdColor =	new THREE.Color( ui.rdColor );
				return ;
			}

			function setRDParams( preset, indice )
			{
				let feed, kill;

				switch ( preset )
				{
					case 'Negative bubbles':
						feed = 0.0980; kill = 0.0555; break;
					case 'Positive bubbles':
						feed = 0.0980; kill = 0.0570; break;
					case 'Precritical bubbles':
						feed = 0.0820; kill = 0.0590; break;
					case 'Worms & loops':
						feed = 0.0820; kill = 0.0600; break;
					case 'Stable solutions':
						feed = 0.0740 ; kill = 0.0640; break;
					case 'U-Skate World':
						feed = 0.0620; kill = 0.0609; break;
					case 'Worms':
						feed = 0.0580; kill = 0.0650; break;
					case 'Worms to maze':
						feed = 0.0460; kill = 0.0630; break;
					case 'Negatons':
						feed = 0.0460; kill = 0.0594; break;
					case 'Turing patterns':
						feed = 0.0420; kill = 0.0590; break;
					case 'Chaos to Turing':
						feed = 0.0390; kill = 0.0580; break;
					case 'Fingerprints':
						feed = 0.0370; kill = 0.0600; break;
					case 'Chaos & negatons':
						feed = 0.0353; kill = 0.0566; break;
					case 'Spots & worms':
						feed = 0.0340; kill = 0.0618; break;
					case 'Replicating spots':
						feed = 0.0300; kill = 0.0630; break;
					case 'Resonant mazes':
						feed = 0.0300; kill = 0.0565; break;
					case 'Mazes':
						feed = 0.0290; kill = 0.0570; break;
					case 'Mazes & chaos':
						feed = 0.0260; kill = 0.0550; break;
					case 'Chaos':
						feed = 0.0260; kill = 0.0510; break;
				}
				switch ( indice )
				{
					case 0:
						ui.rdFeedA = feed; ui.rdKillA = kill; break;
					case 1:
						ui.rdFeedB = feed; ui.rdKillB = kill; break;
				}
				return ;
			}

			function setRD()
			{
				setRDParams( ui.rdPresetA, 0 );
				setRDParams( ui.rdPresetB, 1 );
				setRDVariables();
				setRDCells();
				// setRDMesh();
				updateRDCellsFromCA();
				setMS();
				frameCount = 0;
				return ;
			}

			function displayCA()
			{
				let index;
				let colors, color;

				index = 0;
				colors = caMesh.geometry.attributes.color.array;
				for ( let i = 0; i < ui.caRows; i++ )
					for ( let j = 0; j < ui.caColumns; j++ )
					{
						if (caCellsPrev[i][j] != 0 || caCells[i][j] != 0)
							caCellsPrev[i][j] == 0 ? color = caColorBorn :
							caCells[i][j] == 0 ? color = caColorDeath : color = caColorStasis;
						else
							color = caColorBack;

						colors.set( new Float32Array( [
												color.r, color.g, color.b,
												color.r, color.g, color.b,
												color.r, color.g, color.b,
												color.r, color.g, color.b,
												color.r, color.g, color.b,
												color.r, color.g, color.b
											] ), index );
						index += 18;
					}
				caMesh.geometry.attributes.color.needsUpdate = true;
				return ;
			}

			function getCANeighbors( x, y )
			{
				let neighbors;
				
				neighbors = 0;
				x += ui.caColumns;
				y += ui.caRows;
				for ( let i = -1; i <= 1; i++ )
					for ( let j = -1; j <= 1; j++ )
						neighbors += caCellsPrev[( i + y ) % ui.caRows][( j + x ) % ui.caColumns];
				return ( neighbors );
			}

			function updateCACells()
			{
				let neighbors;

				caCellsPrev = [];
				for ( let i = 0; i < caCells.length; i++ )
					caCellsPrev[i] = caCells[i].slice( 0 );
				for ( let i = 0; i < ui.caRows; i++ )
					for ( let j = 0, index = 0; j < ui.caColumns; j++ )
					{
						neighbors = getCANeighbors( j, i );
						if ( caCellsPrev[i][j] == 0 && caRuleBorn[neighbors] == 1 )
							caCells[i][j] = 1;
						else if ( caCellsPrev[i][j] == 1 && caRuleStasis[neighbors] == 0 )
							caCells[i][j] = 0;
					}
				return ;
			}

			function setCAMesh()
			{
				let v;
				let colors;
				let position, positions;
				let geometry, material;
				let index;
				
				index =		0;
				position =	new THREE.Vector3();
				v =		[4];
				colors =	new Float32Array( (ui.caRows) * (ui.caColumns) * 6 * 3 );
				positions =	colors.slice( 0 );
				for ( let i = 0; i < ui.caRows; i++ )
					for ( let j = 0; j < ui.caColumns; j++ )
					{
						position.x = (j - 0.5) * ui.caCellSize - caOffset.x;
						position.y = -(i + 0.5) * ui.caCellSize + caOffset.y;
						position.z = 0.;

						v[0] = position.clone();
						v[1] = new THREE.Vector3( ui.caCellSize, 0., 0. ).add( position );
						v[2] = new THREE.Vector3( ui.caCellSize, ui.caCellSize, 0. ).add( position );
						v[3] = new THREE.Vector3( 0., ui.caCellSize, 0 ).add( position );

						positions.set( new Float32Array( [
													v[0].x, v[0].y, v[0].z,
													v[1].x, v[1].y, v[1].z,
													v[2].x, v[2].y, v[2].z,
													v[0].x, v[0].y, v[0].z,
													v[2].x, v[2].y, v[2].z,
													v[3].x, v[3].y, v[3].z
												] ), index );
						index += 18;
					}
				geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				material = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors, side: THREE.DoubleSide } );
				scene.remove( caMesh );
				caMesh = new THREE.Mesh( geometry, material );
				scene.add( caMesh );
				return ;
			}

			function setCACells()
			{
				let	halfCols, halfRows;

				halfCols =	ui.caColumns * 0.5;
				halfRows =	ui.caRows * 0.5;
				caCells =	new Array( ui.caRows );
				for ( let i = 0; i < ui.caRows; i++ )
					caCells[i] = new Array( ui.caColumns ).fill( 0 );
				caCells[0][0] = 1;
				caCells[0][ui.caColumns - 1] = 1;
				caCells[ui.caRows - 1][0] = 1;
				caCells[ui.caRows - 1][ui.caColumns - 1] = 1;
				caCells[halfRows - 1][halfCols - 1] = 1;
				caCells[halfRows - 1][halfCols] = 1;
				caCells[halfRows][halfCols - 1] = 1;
				caCells[halfRows][halfCols] = 1;
				return ;
			}

			function setCARuleState( index, rule )
			{
				for ( let i = 0; i < 9; i++ )
					if ( ui.caRule.charCodeAt( index ) == '0'.charCodeAt(0) + i )
						rule[i] = 1;
				return ;
			}

			function setCARule()
			{
				let	index;

				index = 0;
				for ( let i = 0; i < 9; i++ )
					caRuleBorn[i] = caRuleStasis[i] = 0;
				if ( ui.caRule.charAt( 0 ) == 'B' )
				{
					while ( ++index < ui.caRule.length && ui.caRule.charAt( index ) != '/' )
						setCARuleState( index, caRuleBorn );
					while ( ++index < ui.caRule.length )
						setCARuleState( index, caRuleStasis );
				}
				return ;
			}

			function setCAVariables()
			{
				caOffset =		new THREE.Vector2( ui.caColumns, ui.caRows ).divideScalar( 2.0 );
				caOffset =		caOffset.addScalar( -0.5 ).multiplyScalar( ui.caCellSize );
				caColorBorn = 	new THREE.Color( ui.caColorBorn );
				caColorStasis =	new THREE.Color( ui.caColorStasis );
				caColorDeath =	new THREE.Color( ui.caColorDeath );
				caColorBack =	new THREE.Color( ui.caColorBack );
				return ;
			}

			function setCA()
			{
				setCARule();
				setCAVariables();
				setCACells();
				setCAMesh();
				for ( let i = 0; i < ui.caGeneration; i++ )
					updateCACells();
				displayCA();
				return ;
			}

			function setRug()
			{
				setCA();
				setRD();
				return ;
			}

			/*
			** User interface function
			*/

			function createGUI()
			{
				let gui;
				let folderCA, folderRD, folderMS;
				let svgExport;

				gui = new GUI();
				document.getElementById( 'gui-container' ).appendChild( gui.domElement );
				
				folderCA = gui.addFolder( 'Cellular automata' );
				folderCA.add( ui, 'caRule').name( 'rule' ).listen().onChange( function () { setRug() } );
				folderCA.add( ui, 'caColumns', 16, 64, 4 ).name( 'columns' ).listen().onChange( function () { setRug() } );
				folderCA.add( ui, 'caRows', 16, 64, 4 ).name( 'rows' ).listen().onChange( function () { setRug() } );
				folderCA.add( ui, 'caCellSize', 4, 40, 1 ).name( 'cellSize' ).listen().onChange( function () { setRug() } );
				folderCA.add( ui, 'caGeneration', 0, 256, 1 ).name( 'generation' ).listen().onChange( function () { setRug() } );
				folderCA.addColor( ui, 'caColorBorn' ).name( 'colorBorn' ).listen().onChange( function () { setCA() } );
				folderCA.addColor( ui, 'caColorStasis' ).name( 'colorStasis' ).listen().onChange( function () { setCA() } );
				folderCA.addColor( ui, 'caColorDeath' ).name( 'colorDeath' ).listen().onChange( function () { setCA() } );
				folderCA.addColor( ui, 'caColorBack' ).name( 'colorBack' ).listen().onChange( function () { setCA() } );

				folderRD = gui.addFolder( 'Reaction diffusion' );
				folderRD.add( ui, 'rdCellSize', 2, 20, 0.5 ).name( 'cellSize' ).listen().onChange( function () { setRD() } );
				folderRD.add( ui, 'rdPresetA', rdStates ).name( 'presetTopLeft' ).onChange( function () { setRD() } ).listen();
				folderRD.add( ui, 'rdPresetB', rdStates ).name( 'presetBotRight' ).onChange( function () { setRD() } ).listen();
				folderRD.add( ui, 'rdIteration', 0, 2048, 1 ).name( 'iterationMax' ).listen().onChange( function () { setRD() } );
				folderRD.addColor( ui, 'rdColor' ).name( 'color' ).listen().onChange( function () { setMS() } );
				
				svgExport = { add:function(){ exportToSVG(); } };
				gui.add( svgExport, 'add' ).name( 'Export to SVG' );
				return ;
			}

			function init()
			{
				container = document.getElementById( 'container' );

				camera = new THREE.OrthographicCamera( -container.clientWidth / 2.0, container.clientWidth / 2.0, container.clientHeight / 2.0, -container.clientHeight / 2.0, -800, 8000 );
				camera.zoom = 0.5;
				camera.updateProjectionMatrix();
				controls = new OrbitControls( camera, container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf8f8ff );

				setRug();
				createGUI();

				renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( container.clientWidth, container.clientHeight );

				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
				return ;
			}

			function onWindowResize()
			{
				camera.left = -container.clientWidth / 2.0;
				camera.right = container.clientWidth / 2.0;
				camera.top = container.clientHeight / 2.0;
				camera.bottom = -container.clientHeight / 2.0;
				camera.updateProjectionMatrix();
				renderer.setSize( container.clientWidth, container.clientHeight );
				return ;
			}

			/*
			function exploreRDStates()
			{
				if ( rdPresetAIndex == 0 && rdPresetBIndex == 0 && frameCount == 0 )
				{
					ui.rdPresetA = rdStates[rdPresetAIndex];
					ui.rdPresetB = rdStates[rdPresetBIndex];
					setRug();
				}
				if ( rdPresetAIndex < rdStates.length )
					if ( rdPresetBIndex < rdStates.length )
						if ( frameCount > ui.rdIteration )
						{
							exportToSVG();
							if (rdPresetBIndex == rdStates.length - 1)
							{
								rdPresetAIndex++;
								rdPresetBIndex = 10;
							}
							else
								rdPresetBIndex++;
							ui.rdPresetA = rdStates[rdPresetAIndex];
							ui.rdPresetB = rdStates[rdPresetBIndex];
							frameCount = 0;
							setRug();
						}
				return ;
			}
			*/

			function animate()
			{
				requestAnimationFrame( animate );
				if ( frameCount < ui.rdIteration )
				{
					updateRDCells();
				//	displayRD();
					updateMSCellsFromRD();
					displayMS();
				}
				// exploreRDStates();
				controls.update();
				renderer.render( scene, camera );
				frameCount++;
				return ;
			}

			function exportToSVG()
			{
				let rendererSVG;
				
				rendererSVG = new SVGRenderer();
				rendererSVG.setSize( window.innerWidth, window.innerHeight );
				rendererSVG.render( scene, camera );
				if ( rdPresetAIndex < 10 && rdPresetBIndex < 10 )
					saveToSVG(rendererSVG, 'RUG_0' + rdPresetAIndex + '_0' + rdPresetBIndex + '.svg');
				else if ( rdPresetAIndex < 10 )
					saveToSVG(rendererSVG, 'RUG_0' + rdPresetAIndex + '_' + rdPresetBIndex + '.svg');
				else if ( rdPresetBIndex < 10 )
					saveToSVG(rendererSVG, 'RUG_' + rdPresetAIndex + '_0' + rdPresetBIndex + '.svg');
				else
					saveToSVG(rendererSVG, 'RUG_' + rdPresetAIndex + '_' + rdPresetBIndex + '.svg');
				return ;
			}

			function saveToSVG(rendererSVG, filename)
			{
				var XMLS;
				var preface, downloadLink;
				var svgfile, svgBlob;

				XMLS = new XMLSerializer(); 
				svgfile = XMLS.serializeToString(rendererSVG.domElement); 
				preface = '<?xml version="1.0" standalone="no"?>\r\n';
				svgBlob = new Blob([preface, svgfile], {type:"image/svg+xml;charset=utf-8"});
				downloadLink = document.createElement("a");
				downloadLink.href = URL.createObjectURL(svgBlob);
				downloadLink.download = filename;
				document.body.appendChild(downloadLink);
				downloadLink.click();
				document.body.removeChild(downloadLink);
				return ;
			}
		</script>
	</body>
</html>